# 期末项目报告

## 小组成员分工

| 姓名   | 学号     | 分工                                           |
| ------ | -------- | ---------------------------------------------- |
| 陈伟桐 | 16340034 | 项目场景搭建、阴影和抗锯齿、爆炸效果           |
| 陈星宇 | 16340039 | 项目框架搭建、光照、模型导入、天空盒、粒子系统 |
| 陈彦行 | 16340043 | 方块的添加与删除、重力系统与碰撞检测           |

## 项目介绍
我们的项目是做一个类似于我的世界的一个游戏，这个游戏世界主要由一个个方块构成，不同方块的组合可以构成各式各样的建筑和场景。玩家可以通过“背包”选择不同的方块进行添加，也可以任意破环游戏世界中的方块。

这个游戏的主要功能为：可以选择不同的方块并在场景中添加该方块，可以破坏场景中的方块、摄像机视角的自由移动、光照与阴影、方块纹理贴图、模型的导入、天空盒、文字的显示、重力系统与碰撞检测、雨雪粒子系统、特殊方块的爆炸效果、抗锯齿。

## 实现结果
项目实现结果如本目录下的演示视频所示。

## 开发环境及第三方库
本项目的开发在 windows 系统下进行，使用的编辑器是 visual studio 2017，sdk 版本取决于开发成员本地 sdk 版本，解决方案平台为 `x86`，。

本项目使用的第三方库：
- glfw3
- glad
- glm
- imgui
- assimp
- freetype
- stb_image

## 功能列表
本项目实现的功能列表如下：

### Basic
- Camera Roaming
- Simple lighting and shading(phong)
- Texture mapping
- Shadow mapping
- Model import & Mesh viewing

### Bonus
- Sky Box (天空盒)
- Display Text (显示文字，中文/英文/立体/平面)<font color=#FF8C00>（未完成）</font>
- Gravity System and Collision Detection (重力系统与碰撞检测)<font color=#FF8C00>（未完成）</font>
- Particle System (粒子系统: 渲染雨、雪、雾等)<font color=#FF8C00>（未完成）</font>
- Explosion Eﬀect (爆炸效果)<font color=#FF8C00>（未完成）</font>
- Anti-Aliasing (抗锯齿)

## 功能介绍

### Shadow mapping
对于阴影(Shadow mapping)，我们使用的是传统的阴影映射方法。

![](https://gitee.com/watchcat2k/pictures_base/raw/master/2019-05/2019-05-14-1.png)

在深度测试中，在深度缓冲里的一个值是摄像机视角下，对应于一个片元的一个0到1之间的深度值。我们从光源的透视图来渲染场景，并把深度值的结果储存到纹理中，这样就能对光源的透视图所见的最近的深度值进行采样。最终，深度值就会显示从光源的透视图下见到的第一个片元了。我们管储存在纹理中的所有这些深度值，叫做深度贴图或阴影贴图。

利用每个片元的深度值，我们可比较在同一条光线上的点谁距离光源更近，距离最近的点是可视的被光线照射的点，而距离较远的则被视为阴影。

为了实现阴影映射，我们首先需要生成一张深度贴图。深度贴图是从光的透视图里渲染的深度纹理。然后把生成的深度纹理作为帧缓冲的深度缓冲，之后生成深度贴图。最后便是阴影的计算，这部分在片段着色器进行，如下：
```
float ShadowCalculation(vec4 fragPosLightSpace)
{
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    projCoords = projCoords * 0.5 + 0.5;
    float closestDepth = texture(shadowMap, projCoords.xy).r; 
    float currentDepth = projCoords.z;
    vec3 normal = normalize(fs_in.Normal);
    vec3 lightDir = normalize(lightPos - fs_in.FragPos);
    float bias = max(0.05 * (1.0 - dot(normal, lightDir)), 0.005);
    float shadow = 0.0;
    vec2 texelSize = 1.0 / textureSize(shadowMap, 0);
    for(int x = -1; x <= 1; ++x)
    {
        for(int y = -1; y <= 1; ++y)
        {
            float pcfDepth = texture(shadowMap, projCoords.xy + vec2(x, y) * texelSize).r; 
            shadow += currentDepth - bias > pcfDepth  ? 1.0 : 0.0;        
        }    
    }
    shadow /= 9.0;
    
    if(projCoords.z > 1.0)
        shadow = 0.0;
        
    return shadow;
}
```

最终的效果如下：

![](https://gitee.com/watchcat2k/pictures_base/raw/master/2019-06/2019-06-21-2.png)